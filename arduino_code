

//
// Autonomous RC Car
// 



#include <Wire.h>                                 // used by: motor driver
#include <NewPing.h>                              // Ping sonar
#include <LiquidCrystal_I2C.h>                    // LCD library
#include "Adafruit_Sensor.h"                      // part of mag sensor
#include "Adafruit_LSM303_U.h"                    // mag sensor
#include "waypointClass.h"                        // custom class to manaage GPS waypoints
#include "Adafruit_GPS.h"                         // GPS
#include "SoftwareSerial.h"                       // used by: GPS
#include "math.h"                                 // used by: GPS
#include "moving_average.h"                       // simple moving average class; for Sonar functionality
#include "tinyGPS.h"



#define USE_GRAPHING YES            // comment out to skip graphing functions in LCD display
#define USE_LCD_BACKLIGHT YES       // use backlight on LCD; commenting out may help in direct sunlight
#define DEBUG YES                   // debug mode; uses Serial Port, displays diagnostic information, etc. 
//#define NO_GPS_WAIT YES           // define this for debugging to skip waiting for GPS fix


// Setup magnemeter  (compass); uses I2C
Adafruit_LSM303_Mag_Unified mag = Adafruit_LSM303_Mag_Unified(12345);


// Setup motor controllers for both drive and steering (turn).
//--- Declared variables

int leftmotorForward = 8; // pin 8 --- left motor (+) green wire

int leftmotorBackward = 11; // pin 11 --- left motor (-) black wire

int leftmotorspeed = 9; // pin 9 --- left motor speed signal

int rightmotorForward = 12; // pin 12 --- right motor (+) green wire

int rightmotorBackward = 13; // pin 13 --- right motor (-) black

int rightmotorspeed = 10; // pin 10 --- right motor speed signal

//--- Speeds

int Slow = 100; // slow speed (of 255 max)

int Normal = 200;

int Fast = 250; // fast speed (of 255 max)

// LCD Display
LiquidCrystal_I2C lcd(0x3F, 20, 4);  // Set the LCD I2C address and size (4x20)
#define LEFT_ARROW 0x7F
#define RIGHT_ARROW 0x7E
#define DEGREE_SYMBOL 0xDF


// Ultrasonic ping sensor
#define TRIGGER_PIN  6
#define ECHO_PIN  6
#define MAX_DISTANCE_CM 250                        // Maximum distance we want to ping for (in CENTIMETERS). Maximum sensor distance is rated at 400-500cm.  
#define MAX_DISTANCE_IN (MAX_DISTANCE_CM / 2.5)    // same distance, in inches
int sonarDistance;
int cf;
NewPing sonar(TRIGGER_PIN, ECHO_PIN, MAX_DISTANCE_CM);     // NewPing setup of pins and maximum distance.
MovingAverage<int, 3> sonarAverage(MAX_DISTANCE_IN);       // moving average of last n pings, initialize at MAX_DISTANCE_IN


// Compass navigation
int targetHeading;              // where we want to go to reach current waypoint
int currentHeading;             // where we are actually facing now
int headingError;               // signed (+/-) difference between targetHeading and currentHeading
#define HEADING_TOLERANCE 10   // tolerance +/- (in degrees) within which we don't attempt to turn to intercept targetHeading
#define SerialDebug true
#define AHRS true


// GPS Navigation
#define GPSECHO true           // set to TRUE for GPS debugging if needed ***changed
//#define GPSECHO true           // set to TRUE for GPS debugging if needed
SoftwareSerial mySerial(4, 3);    // digital pins 7 & 8
Adafruit_GPS GPS(&mySerial);
boolean usingInterrupt = false;
float currentLat,
      currentLong,
      targetLat,
      targetLong,
      delta;
int distanceToTarget,            // current distance to target (current waypoint)
    originalDistanceToTarget;    // distance to original waypoing when we started navigating to it


// Waypoints
#define WAYPOINT_DIST_TOLERANE  3   // tolerance in meters to waypoint; once within this tolerance, will advance to the next waypoint
#define NUMBER_WAYPOINTS 2          // enter the numebr of way points here (will run from 0 to (n-1))
int waypointNumber = -1;            // current waypoint number; will run from 0 to (NUMBER_WAYPOINTS -1); start at -1 and gets initialized during setup()
waypointClass waypointList[NUMBER_WAYPOINTS] = { waypointClass(-67.1417, 18.2079), waypointClass(-67.1417, 18.2078) };


// Object avoidance distances (in inches)
#define SAFE_DISTANCE 80
#define TURN_DISTANCE 60
#define STOP_DISTANCE 20


// Speeds (range: 0 - 255)
#define FAST_SPEED 160
#define NORMAL_SPEED 130
#define TURN_SPEED 100
#define SLOW_SPEED 75
int speed = NORMAL_SPEED;



// Interrupt is called once a millisecond, looks for any new GPS data, and stores it
SIGNAL(TIMER0_COMPA_vect)
{
  GPS.read();
}


//
// turn interrupt on and off
void useInterrupt(boolean v)
{
  if (v) {
    // Timer0 is already used for millis() - we'll just interrupt somewhere
    // in the middle and call the "Compare A" function above
    OCR0A = 0xAF;
    TIMSK0 |= _BV(OCIE0A);
    usingInterrupt = true;
  } else {
    // do not call the interrupt function COMPA anymore
    TIMSK0 &= ~_BV(OCIE0A);
    usingInterrupt = false;
  }
}



void setup()
{
  Serial.begin(115200);        // we need this speed for the GPS

 
  // Start LCD display
  lcd.init();            // start the LCD...new version doesn't require size startup parameters
#ifdef USE_LCD_BACKLIGHT
  lcd.backlight();
#else
  lcd.noBacklight();
#endif
  lcd.clear();
#ifdef USE_GRAPHING
  createLCDChars();  // initialize LCD with graphing characters
#endif

  //
  // Start motor drives

  //---6 Pins being used are outputs---


  pinMode(leftmotorForward, OUTPUT);

  pinMode(leftmotorBackward, OUTPUT);

  pinMode(leftmotorspeed, OUTPUT);

  pinMode(rightmotorForward, OUTPUT);

  pinMode(rightmotorBackward, OUTPUT);

  pinMode(rightmotorspeed, OUTPUT);


  //start Mag / Compass
  if (!mag.begin())
  {
#ifdef DEBUG
    Serial.println(F("COMPASS ERROR"));
#endif
    lcd.print(F("COMPASS ERROR"));
    loopForever();         // loop forever, can't operate without compass
  }



  // start GPS and set desired configuration
  GPS.begin(9600);                                // 9600 NMEA default speed
  GPS.sendCommand(PMTK_SET_NMEA_OUTPUT_RMCGGA);     // turns on RMC and GGA (fix data)
  GPS.sendCommand(PMTK_SET_NMEA_UPDATE_1HZ);       // 1 Hz update rate
  GPS.sendCommand(PGCMD_NOANTENNA);                // turn off antenna status info
  useInterrupt(true);                            // use interrupt to constantly pull data from GPS
  delay(1000);


  // Wait for GPS to get signal
#ifndef NO_GPS_WAIT
  lcd.setCursor(0, 0);
  lcd.print(F("Waiting for GPS"));
  unsigned long startTime = millis();
  while (!GPS.fix)                      // wait for fix, updating display with each new NMEA sentence received
  {
    lcd.setCursor(0, 1);
    lcd.print(F("Wait Time: "));
    lcd.print((int) (millis() - startTime) / 1000);     // show how long we have waited
    if (GPS.newNMEAreceived())
      GPS.parse(GPS.lastNMEA());
  } 
#endif



  // get initial waypoint; also sets the distanceToTarget and courseToTarget varilables
  nextWaypoint();

} // setup()




void loop()
{



  // Process GPS
  if (GPS.newNMEAreceived())               // check for updated GPS information
  {
    if (GPS.parse(GPS.lastNMEA()) )     // if we successfully parse it, update our data fields
     processGPS();
  }

  // navigate
  currentHeading = readCompass();    // get our current heading
  calcDesiredTurn(); // calculate how we would optimatally turn, without regard to obstacles
  delay(10);
  // distance in front of us, move, and avoid obstacles as necessary
  checkSonar();
  moveAndAvoid();

  // update display and serial monitor
  updateDisplay();

}  // loop()
void goForward()

{

  analogWrite(leftmotorspeed, Normal); //Enable left motor by setting speed

  analogWrite(rightmotorspeed, Normal); //Enable left motor by setting speed

  digitalWrite(leftmotorBackward, LOW); // Drives LOW outputs down first to avoid damage

  digitalWrite(rightmotorBackward, LOW);

  digitalWrite(leftmotorForward, HIGH);

  digitalWrite(rightmotorForward, HIGH);

}

void goSlow()
{

  analogWrite(leftmotorspeed, Slow); //Enable left motor by setting speed

  analogWrite(rightmotorspeed, Slow); //Enable left motor by setting speed

  digitalWrite(leftmotorBackward, LOW); // Drives LOW outputs down first to avoid damage

  digitalWrite(rightmotorBackward, LOW);

  digitalWrite(leftmotorForward, HIGH);

  digitalWrite(rightmotorForward, HIGH);

}
void goRight()

{

  analogWrite(leftmotorspeed, Slow);

  analogWrite(rightmotorspeed, Slow);

  digitalWrite(leftmotorBackward, HIGH);

  digitalWrite(rightmotorBackward, LOW);

  digitalWrite(leftmotorForward, LOW);

  digitalWrite(rightmotorForward, HIGH);

}

void goLeft()

{

  analogWrite(leftmotorspeed, Slow);

  analogWrite(rightmotorspeed, Slow);

  digitalWrite(leftmotorBackward, LOW);

  digitalWrite(rightmotorBackward, HIGH);

  digitalWrite(leftmotorForward, HIGH);

  digitalWrite(rightmotorForward, LOW);

}

void goBackward()

{

  analogWrite(leftmotorspeed, Normal);

  analogWrite(rightmotorspeed, Normal);

  digitalWrite(leftmotorForward, LOW);

  digitalWrite(rightmotorForward, LOW);

  digitalWrite(leftmotorBackward, HIGH);

  digitalWrite(rightmotorBackward, HIGH);

}

void pare() // Sets speed pins to LOW disabling both motors

{

  digitalWrite(leftmotorspeed, LOW);

  digitalWrite(rightmotorspeed, LOW);

}



// Called after new GPS data is received; updates our position and course/distance to waypoint
void processGPS(void)
{
  currentLat = convertDegMinToDecDeg(GPS.latitude);
  currentLong = convertDegMinToDecDeg(GPS.longitude);

  if (GPS.lat == 'S')            // make them signed
    currentLat = -currentLat;
  if (GPS.lon = 'W')
    currentLong = -currentLong;

  // update the course and distance to waypoint based on our new position
  distanceToWaypoint();
  courseToWaypoint();

}   // processGPS(void)



void checkSonar(void)
{
  int dist;
  cf=1.0121; 

  dist = sonar.ping_in();                   // get distance in inches from the sensor
  if (dist == 0)                                // if too far to measure, return max distance;
    dist = MAX_DISTANCE_IN;
  sonarDistance = sonarAverage.add(dist)*cf;      // add the new value into moving average, use resulting average
} // checkSonar()




int readCompass(void)
{
  sensors_event_t event;
  mag.getEvent(&event);


  // Calculate the angle of the vector y,x
  float heading = (atan2(event.magnetic.y, event.magnetic.x));

#define DEC_ANGLE 0.217
  heading += DEC_ANGLE;

  // Correct for when signs are reversed.
  if (heading < 0)
    heading += 2 * PI;

  // Check for wrap due to addition of declination.
  if (heading > 2 * PI)
    heading -= 2 * PI;

  // Convert radians to degrees for readability.
  float headingDegrees = heading * 180 / M_PI;

  return ((int)headingDegrees);

}// readCompass()



void calcDesiredTurn()
{
  // calculate where we need to turn to head to destination
  headingError = targetHeading - currentHeading;

  // adjust for compass wrap
  if (headingError < -180)
    headingError += 360;
  if (headingError > 180)
    headingError -= 360;

  // calculate which way to turn to intercept the targetHeading
  if (abs(headingError) <= HEADING_TOLERANCE)      // if within tolerance, don't turn
    goForward();
    
  else if (headingError < 0)
    goLeft();
    
  else if (headingError > 0)
    goRight();
    
  else 
  goForward();
}  // calcDesiredTurn()




void moveAndAvoid()
{
  if (sonarDistance <  STOP_DISTANCE)          // too close, stop and back up
  {
   goBackward();
     delay(3000);
    
             while (sonarDistance < TURN_DISTANCE)       // backup until we get safe clearance
           {
            
              if(GPS.parse(GPS.lastNMEA()) )
                 processGPS();  
              currentHeading = readCompass();    // get our current heading
              calcDesiredTurn();                // calculate how we would optimatally turn, without regard to obstacles      
              checkSonar();
              updateDisplay();
              delay(100);
           }
           pare();
    return;
    }
  if (sonarDistance >= SAFE_DISTANCE)       // no close objects in front of car
  {
    goForward();
  }
 
  else
  {
    goSlow();
  }
  return;


  if (sonarDistance > TURN_DISTANCE && sonarDistance < SAFE_DISTANCE)    // not yet time to turn, but slow down
  {
   
    if (goForward) {
      analogWrite(leftmotorspeed, Fast);
      analogWrite(rightmotorspeed, Fast);
    }
    else
    {
      analogWrite(leftmotorspeed, Slow);
      analogWrite(rightmotorspeed, Slow);     // alraedy turning to navigate
    }
    return;
  }

  if (sonarDistance <  TURN_DISTANCE && sonarDistance > STOP_DISTANCE)  // getting close, time to turn to avoid object
  {
    analogWrite(leftmotorspeed, Slow);
    analogWrite(rightmotorspeed, Slow);

    if (goForward) {
      if (headingError <= 0) {
        goLeft;
      }
      else
        goRight;
      //            break;

      if (goRight) {
        goLeft;
        //         break;
      }
      if (goLeft) {
        goRight;
        //           break;
      }
    }
  }
            
  
}
#ifdef USE_GRAPHING
void createLCDChars(void)
{
  int lvl = 0;
  byte arry[8];
  for (int a = 7; a >= 0; a--)
  {
    for (int b = 0; b <= 7; b++)
    {
      if (b >= lvl)
        arry[b] = B11111;       // solid
      else
        arry[b] = B10001;       // hollow but with sides
    }
    lcd.createChar(a, arry);
    lvl++;
  }
}  // createLCDChars(void)
#endif

void loopForever(void)
{
  while (1);
}

void nextWaypoint(void)
{
  waypointNumber++;
  targetLat = waypointList[waypointNumber].getLat();
  targetLong = waypointList[waypointNumber].getLong();

  if ((targetLat == 0 && targetLong == 0) || waypointNumber >= NUMBER_WAYPOINTS)    // last waypoint reached?
  {
    pare();
    lcd.clear();
    lcd.println(F("* LAST WAYPOINT *"));
    loopForever();
  }

  processGPS();
  distanceToTarget = originalDistanceToTarget = distanceToWaypoint();
  courseToWaypoint();

}  // nextWaypoint()

int distanceToWaypoint()
{

  float delta = radians(currentLong - targetLong); 
  float sdlong = sin(delta);
  float cdlong = cos(delta);
  float lat1 = radians(currentLat);
  float lat2 = radians(targetLat);
  float slat1 = sin(lat1);
  float clat1 = cos(lat1);
  float slat2 = sin(lat2);
  float clat2 = cos(lat2);
  delta = (clat1 * slat2) - (slat1 * clat2 * cdlong);
  delta = sq(delta);
  delta += sq(clat2 * sdlong);
  delta = sqrt(delta);
  float denom = (slat1 * slat2) + (clat1 * clat2 * cdlong);
  delta = atan2(delta, denom);
  distanceToTarget =  delta * 6372795;

  // check to see if we have reached the current waypoint
  if (distanceToTarget <= WAYPOINT_DIST_TOLERANE)
    nextWaypoint();

  return distanceToTarget;
}

int courseToWaypoint()
{
  float dlon = radians(targetLong - currentLong);
  float cLat = radians(currentLat);
  float tLat = radians(targetLat);
  float a1 = sin(dlon) * cos(tLat);
  float a2 = sin(cLat) * cos(tLat) * cos(dlon);
  a2 = cos(cLat) * sin(tLat) - a2;
  a2 = atan2(a1, a2);
  if (a2 < 0.0)
  {
    a2 += TWO_PI;
  }
  targetHeading = degrees(a2);
  return targetHeading;
}   // courseToWaypoint()

int freeRam ()   // display free memory (SRAM)
{
  extern int __heap_start, *__brkval;
  int v;
  return (int) &v - (__brkval == 0 ? (int) &__heap_start : (int) __brkval);
} // freeRam()

void updateDisplay(void)
{

  static unsigned long lastUpdate = millis();       // for controlling frequency of LCD updates
  unsigned long currentTime;

  // check time since last update
  currentTime = millis();
  if (lastUpdate > currentTime)   // check for time wrap around
    lastUpdate = currentTime;

  if (currentTime >= lastUpdate + 500 )   // limit refresh rate
  {
    lastUpdate = currentTime;

    // line 1
    lcd.clear();
    lcd.print(F("tH= "));
    lcd.print(targetHeading, DEC);
    lcd.write(DEGREE_SYMBOL);
    lcd.print(F(" cH= "));
    lcd.print(currentHeading, DEC);
    lcd.write(DEGREE_SYMBOL);

    // line 2
    lcd.setCursor(0, 1);
    lcd.print(F("Err "));
    if (headingError < 0)
      lcd.write(LEFT_ARROW);
    lcd.print(abs(headingError), DEC);
    if (headingError > 0)
      lcd.write(RIGHT_ARROW);
    lcd.print(F(" Dist "));
    lcd.print(distanceToTarget, DEC);
    lcd.print(F("m "));
#ifdef USE_GRAPHING
    lcd.write(map(distanceToTarget, 0, originalDistanceToTarget, 0, 7));    // show tiny bar graph of distance remaining
#endif

    // line 3
    lcd.setCursor(0, 2);
    lcd.print(F("Snr "));
    lcd.print(sonarDistance, DEC);
#ifdef USE_GRAPHING
    lcd.write(map(sonarDistance, 0, MAX_DISTANCE_IN, 0, 7));
#endif
    lcd.print(F(" Spd "));
    lcd.print(speed, DEC);
#ifdef USE_GRAPHING
    lcd.write(map(speed, 0, 255, 0, 7));
#endif

    // line 4
    lcd.setCursor(0, 3);
    lcd.print(F("Mem "));
    lcd.print(freeRam(), DEC);
    lcd.print(F(" WPT "));
    lcd.print(waypointNumber + 1, DEC);
    lcd.print(F(" OF "));
    lcd.print(NUMBER_WAYPOINTS - 1, DEC);


#ifdef DEBUG
    //Serial.print("GPS Fix:");
    //Serial.println((int)GPS.fix);
    Serial.print(F("LAT = "));
    Serial.print(currentLat);
    Serial.print(F("TargetLAT"));
    Serial.println(targetLat);
    Serial.print(F("TargetLON"));
    Serial.println(targetLong);
    Serial.print(F(" LON = "));
    Serial.println(currentLong);
    Serial.print("Waypint LAT =");
    Serial.print(waypointList[waypointNumber].getLat());
    Serial.print(F(" Long = "));
    Serial.print(waypointList[waypointNumber].getLong());
    Serial.print(F(" Dist "));
    Serial.print(distanceToWaypoint());
    Serial.print(F("Original Dist "));
    Serial.println(originalDistanceToTarget);
    Serial.print(F("Compass Heading "));
    Serial.println(currentHeading);
    Serial.print(F("GPS Heading "));
   // Serial.println(GPS.angle);
   //Serial.println(delta);
  

    //Serial.println(GPS.lastNMEA());

    Serial.print(F("Sonar = "));
    Serial.print(sonarDistance, DEC);
    //Serial.print(F(" Spd = "));
    //Serial.println(speed, DEC);
    //Serial.print(F("  Target = "));
    //Serial.print(targetHeading, DEC);
    //Serial.print(F("  Current = "));
    //Serial.print(currentHeading, DEC);
    //Serial.print(F("  Error = "));
    //Serial.println(headingError, DEC);
    //Serial.print(F("Free Memory: "));
    //Serial.println(freeRam(), DEC);
#endif

  } //  if (currentTime >= lastUpdate + 500 )

}

double convertDegMinToDecDeg (float degMin)
{
  double min = 0.0;
  double decDeg = 0.0;

  //get the minutes, fmod() requires double
  min = fmod((double)degMin, 100.0);

  //rebuild coordinates in decimal degrees
  degMin = (int) ( degMin / 100 );
  decDeg = degMin + ( min / 60 );

  return decDeg;
}

 
